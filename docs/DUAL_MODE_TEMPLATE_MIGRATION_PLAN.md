# Dual-Mode Template Migration: Frontend Refactor Plan

## Requirements Analysis

- **Current State**: Four algorithms with mixed implementation quality—some using custom dashboards, some using basic grids, one using outdated recursive template. All need to align with new approved static mockup templates.
- **Core Goal**: Migrate all 4 algorithms to use the newly approved dual-mode template architecture (iterative metrics dashboard OR recursive context stack), achieving 99% structural consistency while preserving algorithm-specific pedagogical value.
- **Technical Constraints**:
  - Must maintain all LOCKED HTML landmark IDs (#app-root, #app-header, #panel-visualization, #panel-steps, #panel-steps-list, #panel-step-description, #step-current)
  - Panel ratios LOCKED (Left: flex-[3], Right: w-96, Top: flex-[2], Bottom: flex-[1])
  - Keyboard shortcuts unchanged
  - Zero breaking changes to backend JSON contracts
  - Must adhere to ADR-001 (Registry Pattern), ADR-002 (Component Organization), ADR-003 (Context Management)
- **Assumptions to Validate**:
  - 5-zone dashboard grid scales to all iterative algorithms (Binary Search, Sliding Window, Two Pointer)
  - New recursive template structure works for Interval Coverage without data changes
  - Container query units (cqh) work in target browsers (modern Chrome/Firefox/Safari)
  - JSON payloads contain sufficient data for pedagogically rich visualizations

---

## Strategic Approach

- **Why This Phasing?**: Start with architectural foundation (unified StatePanel), then tackle highest-value algorithm (Binary Search—perfect dashboard fit), then refine existing dashboards (Sliding Window, Two Pointer), and finish with recursive pattern (Interval Coverage). Each phase delivers working, testable software.
- **Main Risk Areas**:
  1. Dashboard CSS integration causing conflicts with existing Tailwind utilities
  2. Zone mapping feeling "forced" for Two Pointer (lacks clear "goal" concept)
  3. Interval Coverage API errors blocking JSON payload analysis
  4. Time estimates optimistic (refactoring always surfaces unexpected complexity)
- **Validation Strategy**: After each algorithm migration, run full manual test suite (narrative accuracy, step navigation, visual rendering, keyboard shortcuts). Use static mockups as visual regression baseline.

---

## IMPORTANT NOTE TO THE FRONTEND TEAM

**Management Decision Context:**

Based on the new management decision to adopt a **dual-mode implementation**, all four algorithms must be refactored to use the newly designed layout shown in the static mockup templates, according to algorithm type:

1. **Recursive algorithms** → use: `docs/static_mockup/recursive_context_algorithm_mockup.html`
2. **Iterative algorithms** → use: `docs/static_mockup/iterative_metrics_algorithm_mockup.html`

**Primary Refactoring Area:**

The majority of the refactoring will occur in the **right-side panel**, as this is the primary area that has changed in the templates. However, the frontend team should **not take anything for granted**—verify all assumptions.

---

### Per-Algorithm Workflow (CRITICAL)

For each algorithm, the team **must** follow this process:

**1. Read the Backend Narrative**

The narrative generated by the backend is intended to prepare you for the design and is generally reliable. Read it thoroughly to understand:

- The algorithm's pedagogical goals
- Key decision points
- What students should learn at each step

**2. Analyze the JSON Payload Deeply**

**This is the most critical step.** The markdown narrative provides only a partial picture. The frontend team must perform due diligence by analyzing the JSON, which is **the driving engine of the interactive visualization**.

**Two Key Pitfalls to Avoid:**

**A) Saying too little** when more insight could be provided  
**B) Saying too much** when clarity is lost

You must **strike a balance** between the two. Underwhelming the student with a slide-deck-style presentation of the algorithm is just as harmful as overwhelming them with excessive or redundant information.

**Spatial Constraints:**

The algorithm steps area (right-side panel) is constrained—the dashboard is approximately **384px wide by 400px high**. While it can display only a limited amount of information, **not everything is worth showing**, and **not all metrics are equally important**.

**Strategic Principle:**

**You are telling the story of an algorithm.** The JSON payload contains a wealth of information—use it to your advantage. If you find yourself attempting to reimplement the algorithm logic in the frontend, **pause and ask whether you are reinventing the wheel** in an inefficient or incorrect way.

**3. Create a Visualization Outline**

Before touching code, create a written outline:

- What data will you display?
- How will it map to the 5 zones (iterative) or call stack (recursive)?
- What's the pedagogical narrative at each step?
- What can be safely omitted without loss of clarity?

**4. Create a Static Mockup**

Build a standalone HTML file showing what the algorithm visualization would typically look like at a representative step. This is **required** before implementation begins.

**5. Get Approval & Proceed**

Upon approval of the static mockup for the given algorithm, proceed with refactoring. **Do not implement without mockup approval.**

---

### Template Usage Philosophy

**The two static mockup templates have already been created and approved by management.**

For each algorithm, determine whether it is **recursive or iterative** and select the appropriate template for implementation.

**Use the static mockup templates as a strong starting point, but adapt as necessary when constraints arise.** Study the design templates carefully before implementing your solution.

**The templates are your foundation, not your prison.** If pedagogical clarity requires deviation, document your reasoning and proceed. The goal is effective teaching, not rigid adherence.

---

## Phase 0: Unified StatePanel Foundation (CRITICAL)

### Goal

**Extract 99% of common template structure into a unified StatePanel component, eliminating duplication and establishing clear separation between container (StatePanel) and content (algorithm-specific components).**

### Success Criteria

- ✅ StatePanel.jsx handles both iterative and recursive templates
- ✅ Header section (Algorithm State + Keyboard Hints) identical for all algorithms
- ✅ Footer section (#panel-step-description with badge) identical for all algorithms
- ✅ Template-specific behavior isolated to content padding only
- ✅ Zero regressions in existing algorithms

### Tasks

**0.1: Analyze Current StatePanel Implementation (15 min)**

Review current `StatePanel.jsx` to understand existing structure:

```bash
cat frontend/src/components/panels/StatePanel.jsx
```

Identify refactoring scope:

- What's already unified?
- What needs extraction?
- What's template-specific?

**0.2: Refactor StatePanel to Unified Structure (45 min)**

**Key Changes:**

- Extract common header (Algorithm State title + Keyboard Hints button)
- Extract common footer (#panel-step-description with step badge + description)
- Add template-specific content padding logic:
  - `iterative-metrics`: No padding (dashboard handles own spacing)
  - `recursive-context`: px-6 py-4 (call stack needs breathing room)

**Implementation Pattern:**

```jsx
const StatePanel = () => {
  const { trace, currentAlgorithm } = useTrace();
  const { currentStepData } = useNavigation();
  const StateComponent = getStateComponent(currentAlgorithm);
  const template = getAlgorithmTemplate(currentAlgorithm);
  const badge = getStepTypeBadge(currentStepData?.type);

  // Template-specific content classes
  const contentClasses =
    template === "iterative-metrics"
      ? "flex-1" // Dashboard fills space
      : "flex-1 overflow-y-auto custom-scrollbar px-6 py-4"; // Stack needs padding

  return (
    <div
      id="panel-steps"
      className="w-96 bg-slate-800 rounded-xl shadow-2xl flex flex-col overflow-hidden"
    >
      {/* UNIFIED HEADER */}
      <div
        id="panel-steps-list"
        className="flex-[2] flex flex-col overflow-hidden"
      >
        <div className="flex justify-between px-5 pt-5 items-center mb-4">
          <h2 className="text-xs font-bold text-slate-400 uppercase tracking-widest">
            Algorithm State
          </h2>
          <button onClick={openKeyboardShortcuts} className="...">
            {/* Keyboard icon */}
          </button>
        </div>

        {/* TEMPLATE-SPECIFIC CONTENT */}
        <div className={contentClasses}>
          <StateComponent step={currentStepData} trace={trace} />
        </div>
      </div>

      {/* UNIFIED FOOTER */}
      <div
        id="panel-step-description"
        className="flex-[1] border-t border-slate-700 py-2 px-4 bg-gradient-to-br from-slate-700/60 to-slate-800/60 overflow-hidden flex flex-col"
      >
        <div className="flex-1 overflow-y-auto custom-scrollbar">
          <p className="text-white text-base font-medium leading-relaxed">
            <span
              className={`inline-flex items-center gap-1.5 px-2 py-0.5 mr-2 rounded-md text-xs font-bold ${badge.color} align-middle`}
            >
              {badge.icon} {badge.label}
            </span>
            {currentStepData?.description || "No description available"}
          </p>
        </div>
      </div>
    </div>
  );
};
```

**0.3: Update Registry for Binary Search (5 min)**

Fix incorrect template assignment:

```javascript
// stateRegistry.js
const STATE_REGISTRY = {
  "binary-search": {
    component: BinarySearchState,
    template: "iterative-metrics", // FIXED: was "recursive-context"
  },
  // ... rest unchanged
};
```

**0.4: Integration Testing (15 min)**

- Test all 4 algorithms still render correctly
- Verify keyboard hints button works
- Verify step descriptions display with correct badges
- Verify no visual regressions

### Deliverables

- [ ] `frontend/src/components/panels/StatePanel.jsx` refactored to unified structure
- [ ] `frontend/src/utils/stateRegistry.js` updated (Binary Search template fixed)
- [ ] Manual test: All 4 algorithms render correctly
- [ ] Git commit: "Phase 0: Unify StatePanel architecture for dual-mode templates"

### Rollback Plan

**If** StatePanel changes break existing algorithms: Revert commit, investigate template detection logic, fix, retry. Low risk since we're extracting, not rewriting.

---

## Phase 1: Binary Search - Full 5-Zone Dashboard Implementation (HIGH PRIORITY)

### Goal

**Transform Binary Search from basic metrics grid to production-grade 5-zone dashboard, establishing the iterative metrics pattern for Sliding Window and Two Pointer to follow.**

### Success Criteria

- ✅ Binary Search uses complete 5-zone dashboard (matches `iterative_metrics_algorithm_mockup.html` exactly)
- ✅ All zones populate correctly from JSON payload
- ✅ Dashboard scales responsively using container query units (cqh)
- ✅ Typography hierarchy matches approved template
- ✅ Visual parity with static mockup (no layout shifts, correct colors, proper spacing)
- ✅ Zero regressions in search functionality

### Context

**Why Binary Search First?**

- Perfect semantic fit for 5-zone system (mid/target/comparison/action/boundaries)
- Most complex iterative algorithm (sets quality bar for others)
- Clean JSON payload structure (already analyzed)
- Success here validates dashboard pattern for Sliding Window/Two Pointer

**JSON Payload Structure:**

```javascript
step.data.visualization = {
  array: [{ index, state, value }],
  pointers: { left, mid, right, target },
  search_space_size: number,
};
```

**5-Zone Mapping:**

- Zone 1: Mid value (hero display) + index label
- Zone 2: Target value (goal)
- Zone 3: Comparison logic (mid < / == / > target)
- Zone 4: Next action (Search Left/Right/Return Index)
- Zone 5: Overlay metrics (Left/Right indices + Search Space)

### Tasks

**1.1: Study Backend Narrative (30 min)**

**Action:** Read complete Binary Search narrative to understand pedagogical intent:

```bash
cat docs/narratives/binary-search/example_1_basic_search_target_found.md
```

**Extract:**

- Key decision points (when does comparison happen?)
- Metrics progression (how does search space shrink?)
- Pedagogical moments (what should student notice?)

**Document findings in:** `docs/static_mockup/binary-search-pedagogical-notes.md`

**1.2: Analyze JSON Payload Deeply (30 min)**

**Action:** Pull live trace data and inspect thoroughly:

```bash
curl -X POST http://localhost:5000/api/trace/unified \
  -H "Content-Type: application/json" \
  -d '{"algorithm": "binary-search", "input": {"array": [4,11,12,14,22,23,33,34,39,48,51,59,63,69,70,71,74,79], "target": 59}}' \
  | jq '.' > /tmp/binary-search-trace.json
```

**Analyze:**

- Available data in each step
- State transitions (active_range → examining → found)
- Pointer progression (left/mid/right changes)
- Search space calculation consistency
- Edge cases (initial state with null mid)

**Key Questions:**

- Is `step.data.mid_value` always present? (No—only in CALCULATE_MID steps)
- How do we extract mid value? (From `array[pointers.mid].value`)
- What data is available for Zone 3 logic? (Need to calculate comparison from mid/target)
- What drives Zone 4 action text? (`step.type`: CALCULATE_MID, SEARCH_RIGHT, etc.)

**1.3: Create Static Mockup (60 min)**

**Deliverable:** `docs/static_mockup/binary-search-iterative-dashboard.html`

**Requirements:**

- Copy base structure from `iterative_metrics_algorithm_mockup.html`
- Populate with Binary Search data from Step 6 of narrative (mid=51, target=59)
- Verify all 5 zones render correctly
- Match approved template visual style exactly
- Test in isolation (open in browser, verify layout)

**Zone Content (Step 6 Example):**

```html
<!-- Zone 1: Primary Focus -->
<div class="zone-label">Mid</div>
<div class="zone-meta">IDX 10</div>
<div class="primary-value">51</div>

<!-- Zone 2: Goal -->
<div class="zone-label">Target</div>
<div class="goal-value">59</div>

<!-- Zone 3: Logic -->
<div class="zone-label">LOGIC</div>
<div class="logic-content">
  51 < 59<br />
  SEARCH →
</div>

<!-- Zone 4: Action -->
<div class="action-text">MOVE LEFT POINTER</div>

<!-- Zone 5: Overlay -->
<div class="boundary-cell">
  <div class="boundary-label">Left</div>
  <div class="boundary-value">9</div>
</div>
<div class="boundary-cell">
  <div class="boundary-label">Right</div>
  <div class="boundary-value">12</div>
</div>
<div class="boundary-cell">
  <div class="boundary-label">Space</div>
  <div class="boundary-value">4</div>
</div>
```

**Acceptance Criteria:**

- [ ] All 5 zones visible and properly sized
- [ ] Typography uses container query units (cqh)
- [ ] Colors match approved template (amber primary, emerald goal, white logic)
- [ ] Overlay doesn't collide with mid value (padding-bottom: var(--h-strip))
- [ ] Vertical tab in Zone 3 reads bottom-to-top
- [ ] Opens in browser without errors

**1.4: Get PM Approval (30 min meeting)**

**Present:**

- Static mockup open in browser
- Walk through each zone with sample data
- Explain zone mapping rationale

**Review Checklist:**

- [ ] Zone layout matches template
- [ ] Data values pedagogically meaningful
- [ ] Typography hierarchy clear
- [ ] Color semantics appropriate
- [ ] No visual clutter or confusion

**Decision Gate:**

- ✅ Approved → Proceed to implementation
- ❌ Rejected → Document feedback, revise mockup, re-present

**1.5: Integrate Dashboard CSS (30 min)**

**Decision Point:** How to make dashboard CSS available?

**Option A:** Global stylesheet (Recommended)

```bash
# Extract dashboard CSS from template
cat docs/static_mockup/iterative_metrics_algorithm_mockup.html | \
  grep -A 200 "Dashboard HUD Styles" > /tmp/dashboard.css

# Add to global styles
cat /tmp/dashboard.css >> frontend/src/index.css
```

**Option B:** Component-scoped stylesheet

```bash
# Create shared stylesheet
touch frontend/src/components/algorithm-states/dashboard.css
# Import in BinarySearchState.jsx
```

**Chosen Approach:** Option A (global stylesheet)

- Dashboard is architectural pattern, not component-specific
- Avoids import duplication across 3 iterative algorithms
- Container query CSS variables already global-scoped

**Validation:**

- [ ] Dashboard CSS variables in `:root` section
- [ ] .dashboard class available
- [ ] .zone, .zone-primary, .zone-goal, etc. all defined
- [ ] No conflicts with existing Tailwind utilities

**1.6: Implement BinarySearchState Component (90 min)**

**File:** `frontend/src/components/algorithm-states/BinarySearchState.jsx`

**Implementation Approach:**

1. Data extraction (safe handling of null/undefined)
2. Logic calculation (comparison, action determination)
3. Dashboard rendering (5 zones)
4. Step badge rendering (footer handled by StatePanel)

**Key Code Patterns:**

```jsx
// Safe data extraction
const midIdx = pointers.mid;
const target = pointers.target ?? "?";
let midValue = "-";
if (midIdx !== null && midIdx !== undefined && array[midIdx]) {
  midValue = array[midIdx].value;
}

// Zone 3: Logic calculation
const getComparisonLogic = () => {
  if (midValue === "-") {
    return { text: "INITIALIZE", color: "text-slate-400" };
  }
  if (midValue < target) {
    return {
      text: `${midValue} < ${target}\nSEARCH RIGHT`,
      color: "text-blue-400",
    };
  }
  if (midValue > target) {
    return {
      text: `${midValue} > ${target}\nSEARCH LEFT`,
      color: "text-red-400",
    };
  }
  return { text: `${midValue} == ${target}\nFOUND!`, color: "text-green-400" };
};

// Zone 4: Action text
const getActionText = (type) => {
  if (type?.includes("CALCULATE")) return "CALCULATE MID INDEX";
  if (type?.includes("FOUND")) return "RETURN INDEX";
  if (logic.text.includes("RIGHT")) return "MOVE LEFT POINTER";
  if (logic.text.includes("LEFT")) return "MOVE RIGHT POINTER";
  return "INITIALIZE SEARCH";
};

// Dashboard structure
return (
  <div className="h-full flex flex-col bg-slate-800">
    <div className="flex-[2] flex flex-col p-0 overflow-hidden">
      <div className="flex-1">
        <div className="dashboard h-full">{/* 5 zones here */}</div>
      </div>
    </div>

    {/* Step description in StatePanel footer */}
  </div>
);
```

**Critical Requirements:**

- [ ] NO padding on dashboard wrapper (let dashboard fill flex-1)
- [ ] Handle null mid pointer gracefully (initial state)
- [ ] Use `step.type` to drive Zone 3 & 4 content
- [ ] PropTypes defined for type safety
- [ ] All data comes from props (no direct context consumption—ADR-001)

**1.7: Self-Test Component (30 min)**

**Test Scenarios:**

1. Initial state (no mid calculated yet)
2. First comparison
3. Search left decision
4. Search right decision
5. Target found
6. Target not found (exhaustive search)

**Visual Checks:**

- [ ] Mid value displays (or "-" when null)
- [ ] Target value always visible
- [ ] Comparison logic updates correctly
- [ ] Action text matches step type
- [ ] Overlay shows L/R/Space correctly
- [ ] No collision between overlay and mid value
- [ ] Typography scales with window resize

**Functional Checks:**

- [ ] Step navigation works (arrow keys)
- [ ] No console errors
- [ ] Matches static mockup visually
- [ ] All 18 steps render without errors

**1.8: QA Integration Testing (30 min)**

**Test Matrix:**

| Test Case          | Array Size | Target Location | Expected Result     |
| ------------------ | ---------- | --------------- | ------------------- |
| Small array        | 5          | Middle          | Found quickly       |
| Large array        | 18         | Near end        | Multiple iterations |
| Target not found   | 10         | Not in array    | Exhaustive search   |
| Target at boundary | 15         | First element   | Found at edge       |

**QA Checklist:**

- [ ] Dashboard renders for all test cases
- [ ] Zones populate correctly
- [ ] No layout shifts between steps
- [ ] Keyboard shortcuts still work
- [ ] Visual regression: matches mockup
- [ ] Functional regression: search still works
- [ ] No errors in other algorithms

### Deliverables

- [ ] `docs/static_mockup/binary-search-iterative-dashboard.html` (static mockup)
- [ ] `docs/static_mockup/binary-search-pedagogical-notes.md` (narrative analysis)
- [ ] `frontend/src/index.css` (dashboard CSS integrated)
- [ ] `frontend/src/components/algorithm-states/BinarySearchState.jsx` (complete rewrite)
- [ ] Manual test: All 6 test cases pass
- [ ] Git commit: "Phase 1: Binary Search - Full 5-zone dashboard implementation"

### Rollback Plan

**If** dashboard doesn't work or visual parity fails: Revert commit, keeps old metrics grid. Binary Search remains functional, gives time to debug dashboard CSS conflicts.

---

## Phase 2: Sliding Window - Refine to 5-Zone Dashboard (MEDIUM PRIORITY)

### Goal

**Refine Sliding Window's existing custom dashboard to match 5-zone template structure, enhancing window operation visualization while preserving what works.**

### Success Criteria

- ✅ Sliding Window attempts 5-zone dashboard first
- ✅ If 5-zone feels forced, fallback to refined custom dashboard
- ✅ Window operation math clearly visible (prev - out + in = new)
- ✅ "New max" moment celebrated visually
- ✅ Performance bar shows progress toward max

### Context

**Current State:** Already has dashboard with metrics, needs alignment with template.

**JSON Payload:**

```javascript
step.data.visualization = {
  metrics: {current_sum, max_sum, k, max_window_start},
  pointers: {window_start, window_end}
}
step.data.incoming_element: {index, value} // SLIDE_WINDOW steps only
step.data.outgoing_element: {index, value} // SLIDE_WINDOW steps only
```

**5-Zone Mapping (Attempt 1):**

- Zone 1: Current window sum
- Zone 2: Max sum found
- Zone 3: Performance % (current/max) OR operation math
- Zone 4: Slide operation (prev - out + in = new)
- Zone 5: Window indices + k

### Tasks

**2.1: Narrative + JSON Analysis (30 min)**

Read narrative, analyze JSON, document pedagogical goals:

```bash
cat docs/narratives/sliding-window/example_1_basic.md
```

**Key Questions:**

- What's the "aha moment"? (When sum exceeds previous max)
- What operation needs emphasis? (Window slide math: prev - out + in)
- What metrics matter most? (Current sum, max sum, k)

**2.2: Create 5-Zone Mockup (45 min)**

**Deliverable:** `docs/static_mockup/sliding-window-iterative-dashboard.html`

Attempt 5-zone mapping. If Zone 3 or Zone 4 feel awkward, document concerns for team review.

**2.3: Team Review & Decision (30 min meeting)**

**Present:** Static mockup + concerns

**Decision Gate:**

- ✅ 5-zone works → Proceed with full implementation
- ❌ 5-zone forced → Fall back to refined custom dashboard

**If Fallback Chosen:**

- Keep existing card layout
- Apply dashboard design principles:
  - Use container query units (cqh)
  - Add architectural locking (consistent spacing)
  - Improve visual hierarchy
  - Enhance window operation display

**2.4: Implementation (60 min - varies by decision)**

**If 5-Zone:** Follow Binary Search pattern
**If Custom:** Refine existing component with template principles

**2.5: Testing (30 min)**

Same test matrix as Binary Search (window slides, new max, edge cases)

### Deliverables

- [ ] Static mockup (5-zone OR refined custom)
- [ ] Team decision documented
- [ ] Component implementation
- [ ] Manual test pass
- [ ] Git commit: "Phase 2: Sliding Window - Dashboard refinement"

### Rollback Plan

Low risk—existing dashboard already works. Worst case: keep current implementation, iterate in next sprint.

---

## Phase 3: Two Pointer - Refine to 5-Zone Dashboard (MEDIUM PRIORITY)

### Goal

**Refine Two Pointer's dashboard to match template, solving the "no clear goal" semantic challenge.**

### Success Criteria

- ✅ Two Pointer dashboard aligns with approved pattern
- ✅ Slow/fast pointer distinction clear
- ✅ Comparison moment visually emphasized
- ✅ Write operation highlighted

### Context

**Challenge:** Two Pointer lacks clear "goal" concept. Options:

- Use Fast pointer in Zone 2 (stretches "goal" semantics)
- Use Unique count in Zone 2 (conceptual target)
- Keep custom layout if 5-zone feels forced

**JSON Payload:**

```javascript
step.data.visualization = {
  metrics: { unique_count },
  pointers: { slow, fast },
};
```

### Tasks

**3.1: Narrative + JSON Analysis (30 min)**
**3.2: Create 5-Zone Mockup (45 min)**
**3.3: Team Review & Decision (30 min)**
**3.4: Implementation (60 min)**
**3.5: Testing (30 min)**

(Same pattern as Sliding Window)

### Deliverables

- [ ] Static mockup
- [ ] Team decision documented
- [ ] Component implementation
- [ ] Manual test pass
- [ ] Git commit: "Phase 3: Two Pointer - Dashboard refinement"

---

## Phase 4: Interval Coverage - Migrate to New Recursive Template (HIGH PRIORITY)

### Goal

**Update Interval Coverage to match new recursive template structure, ensuring call stack rendering aligns with approved mockup.**

### Success Criteria

- ✅ Call stack uses new template styling
- ✅ Header/footer structure matches template
- ✅ Depth indentation correct (24px per level)
- ✅ #step-current ID on active call
- ✅ Auto-scroll behavior works

### Context

**Current State:** Uses old recursive pattern. New template has unified structure (99% same as iterative).

**JSON Payload:**

```javascript
step.data.visualization = {
  call_stack_state: [
    { call_id, depth, current_interval, max_end, decision, return_value },
  ],
};
```

### Tasks

**4.1: Compare Templates (30 min)**

Identify deltas between current implementation and new template:

```bash
# Current implementation
cat frontend/src/components/algorithm-states/IntervalCoverageState.jsx

# New template
cat docs/static_mockup/recursive_context_algorithm_mockup.html
```

**Create delta report:**

- Header changes?
- Call frame styling updates?
- Footer structure changes?

**4.2: Create Static Mockup (45 min)**

**Deliverable:** `docs/static_mockup/interval-coverage-recursive-updated.html`

Use Step 12 from narrative (depth 2, examining interval at call #2).

**4.3: Implement Component Updates (60 min)**

**Focus Areas:**

- Update call frame classes to match template
- Ensure #step-current ID on active call
- Verify auto-scroll behavior (scroll-margin: 20px)
- Update step description footer to match template

**4.4: Testing (30 min)**

- [ ] Call stack renders with proper depth
- [ ] Active call scrolls into view
- [ ] Decision badges display correctly
- [ ] Return values visible
- [ ] No regressions

### Deliverables

- [ ] Static mockup
- [ ] Component updates
- [ ] Manual test pass
- [ ] Git commit: "Phase 4: Interval Coverage - Migrate to new recursive template"

---

## Phase 5: CSS Integration & Polish (FINAL)

### Goal

**Ensure dashboard CSS is properly integrated, no conflicts, and visual consistency across all algorithms.**

### Tasks

**5.1: CSS Audit (30 min)**

Verify dashboard CSS doesn't conflict with:

- Existing Tailwind utilities
- Custom component styles
- Modal styles
- Panel layouts

**5.2: Visual Regression Testing (30 min)**

Test all 4 algorithms across:

- Desktop (1920x1080)
- Laptop (1366x768)
- Tablet (iPad - 1024x768)

**5.3: Performance Check (15 min)**

Use React DevTools Profiler to verify no performance regressions.

### Deliverables

- [ ] CSS conflicts resolved
- [ ] Visual parity across viewports
- [ ] Performance baseline maintained
- [ ] Git commit: "Phase 5: CSS integration and polish"

---

## Decision Tree & Stop Conditions

```
START
  ↓
PHASE 0: Unified StatePanel (1-2 hours)
  ├─ All algorithms render → PHASE 1
  ├─ Regressions found → STOP & FIX
  └─ Template detection fails → INVESTIGATE

PHASE 1: Binary Search (4-6 hours)
  ├─ 5-zone works well → PHASE 2
  ├─ Dashboard CSS conflicts → INVESTIGATE & FIX
  ├─ Zone mapping unclear → REVISE MOCKUP
  └─ Visual parity fails → ITERATE

PHASE 2: Sliding Window (3-4 hours)
  ├─ 5-zone works → PHASE 3
  ├─ 5-zone forced → FALLBACK to refined custom
  └─ Team approves → PHASE 3

PHASE 3: Two Pointer (3-4 hours)
  ├─ 5-zone works → PHASE 4
  ├─ 5-zone forced → FALLBACK to refined custom
  └─ Team approves → PHASE 4

PHASE 4: Interval Coverage (3-4 hours)
  ├─ Template matches → PHASE 5
  ├─ Call stack broken → STOP & FIX
  └─ Auto-scroll fails → DEBUG & FIX

PHASE 5: Polish (1-2 hours)
  ├─ All tests pass → COMPLETE ✅
  ├─ CSS conflicts → FIX & RETRY
  └─ Performance issues → OPTIMIZE
```

### Explicit Stop Conditions

**STOP if:**

- Any phase exceeds 2x estimated time
- Test suite failure rate >30%
- CSS conflicts can't be resolved without rewriting entire stylesheet
- Team consensus that templates don't fit algorithms (pivot to custom implementations)
- Backend API changes required (out of scope)

---

## Risk Mitigation Summary

| Risk                              | Likelihood | Impact | Mitigation                                             |
| --------------------------------- | ---------- | ------ | ------------------------------------------------------ |
| Dashboard CSS conflicts           | Medium     | High   | Test in isolation first, scope CSS carefully           |
| Zone mapping forced (Two Pointer) | High       | Medium | Fallback to custom dashboard allowed                   |
| Interval Coverage API broken      | Medium     | High   | Use cached narrative + existing component as reference |
| Time estimates too optimistic     | High       | Medium | Buffer time built into phases, can skip polish         |
| Container query browser support   | Low        | High   | Test across browsers early, fallback to fixed units    |

---

## Success Metrics

### Minimum Viable Success (14-20 hours)

- ✅ StatePanel unified for both templates
- ✅ Binary Search uses 5-zone dashboard
- ✅ Sliding Window & Two Pointer refined (5-zone OR custom)
- ✅ Interval Coverage matches new recursive template
- ✅ Zero functional regressions
- ✅ Visual parity with static mockups

### Stretch Goals (If ahead of schedule)

- Create video walkthrough of dashboard architecture
- Add Storybook stories for dashboard components
- Document dashboard design patterns in README
- Create component template for future algorithms

---

## Scope Boundaries

### In Scope

- ✅ All 4 algorithms migrated to approved templates
- ✅ Unified StatePanel architecture
- ✅ Dashboard CSS integration
- ✅ Static mockup creation per algorithm
- ✅ Visual regression testing
- ✅ Manual QA testing

### Out of Scope

- ❌ Backend JSON payload changes
- ❌ New algorithm additions
- ❌ UI/UX redesign beyond templates
- ❌ Automated visual regression testing (Chromatic, Percy)
- ❌ TypeScript migration
- ❌ Component library changes

---

## Architectural Compliance (ADRs)

### ADR-001: Registry-Based Architecture

**Compliance Requirements:**

- ✅ All algorithm state components registered in `stateRegistry.js`
- ✅ Template metadata in registry (iterative-metrics vs recursive-context)
- ✅ No algorithm-specific logic in `App.jsx` or `StatePanel.jsx`
- ✅ Graceful fallback to DefaultStateComponent

**Validation:** Verify registry has correct template assignments after Phase 0.

### ADR-002: Component Organization Principles

**Compliance Requirements:**

- ✅ Algorithm-specific components in `algorithm-states/` directory
- ✅ Naming convention: `{Algorithm}State.jsx`
- ✅ Reusable visualizations stay in `visualizations/` directory
- ✅ No algorithm-specific components in wrong directory

**Validation:** Run file structure audit after all phases.

### ADR-003: Context-Based State Management

**Compliance Requirements:**

- ✅ State components receive data via props from StatePanel (container)
- ✅ No direct Context consumption in algorithm state components
- ✅ StatePanel acts as container, fetching from contexts
- ✅ Proper separation: containers consume contexts, presentational components receive props

**Validation:** Code review of all state components—ensure no `useTrace()` or `useNavigation()` calls.

---

## Quality Checklist

Before marking each phase complete:

- [ ] Static mockup created and approved (if applicable)
- [ ] Component implementation matches mockup
- [ ] PropTypes defined for type safety
- [ ] Manual test suite passes
- [ ] No console errors or warnings
- [ ] Visual regression check passed
- [ ] Keyboard shortcuts still work
- [ ] Git commit message references phase number
- [ ] ADR compliance verified
- [ ] Can resume work after 1-day break using this plan

---

## Implementation Notes

### Technologies Requiring Research

- **Container Query Units (cqh)**: Verify browser support (https://caniuse.com/css-container-queries)
- **CSS Grid with Row Spanning**: Review grid-row syntax for 5-zone layout
- **Writing Mode Vertical Text**: Test vertical-rl + rotate(180deg) across browsers

### Potential Blockers

- **Interval Coverage API Error**: May need to fix backend first or work with cached data
- **Dashboard CSS Specificity Wars**: May need `!important` or CSS layer organization
- **Zone Mapping Disagreements**: Team may not agree on semantic fit—be prepared to pivot to custom
- **Container Query Polyfill**: May need polyfill for Safari <16

### Recommended Starting Point

1. **Read all narratives first** (understand pedagogy)
2. **Analyze all JSON payloads** (understand data availability)
3. **Complete Phase 0** (foundation for everything)
4. **Tackle Binary Search** (proves pattern works)
5. **Iterate based on learnings** (apply to other algorithms)

---

## Next Steps

1. **Fix Interval Coverage API** (if still broken):

   ```bash
   # Debug backend
   cd backend
   python app.py
   # Test endpoint
   curl -X POST http://localhost:5000/api/trace/unified \
     -H "Content-Type: application/json" \
     -d '{"algorithm": "interval-coverage", "input": {"intervals": [[1,4],[2,5],[7,9]]}}'
   ```

2. **Set up feature branch**:

   ```bash
   git checkout -b feature/dual-mode-template-migration
   git checkout -b feature/phase-0-unified-panel
   ```

3. **Baseline documentation**:

   - Screenshot all 4 current algorithms
   - Document current LOC per component
   - Save for before/after comparison

4. **Start Phase 0**: Begin with StatePanel refactoring (lowest risk, highest value)

---

## Final Notes to Frontend Team

**You Own the Implementation**

This plan provides structure and success criteria, but **you own the code**. If you discover:

- Better zone mappings than suggested
- CSS patterns that work better than template
- Pedagogical improvements not in narrative

**...make the call.** Document your reasoning in PR comments.

**When to Deviate from Template**

The 5-zone dashboard is a **starting point, not a straitjacket**. Deviate when:

- Semantic mapping feels forced
- Custom layout serves pedagogy better
- Template constraints limit clarity

**Just document why** in code comments or PR description.

**Quality Over Speed**

Each algorithm teaches students. **Pedagogical clarity > template compliance**. If choice is between:

- Following template but confusing students
- Custom layout that teaches clearly

**Choose clarity.** We can iterate on consistency later.

**Questions? Concerns?**

This is a collaborative refactor. If:

- Mockup doesn't make sense → flag for team review
- JSON data insufficient → request backend enhancement
- Timeline unrealistic → communicate early

**We adapt the plan, not force the code.**

---

**PM Approval:**

Signed: ActionPlan PM  
Date: 19-12-2025

---
